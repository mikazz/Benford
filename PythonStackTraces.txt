Traceback Problem 1
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 45, in <lambda>
    run_trace(1, lambda: perform_calculation(add, '1', 3))
  File "stack_traces.py", line 8, in perform_calculation
    calc(x, y)
  File "stack_traces.py", line 12, in add
    return x + y
TypeError: can only concatenate str (not "int") to str


The value you are concatenating needs to be same type, both int or str. 
Quotes makes this difference. Remove them manually from '1' in line 45 or convert it to int('1') 
to "performs_calculations" correctly

>>> type('1')
<class 'str'>
>>> type(3)
<class 'int'>
>>> type('1') is type(3)
False


Traceback Problem 2
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 46, in <lambda>
    run_trace(2, lambda: perform_calculation(add, 7, '3'))
  File "stack_traces.py", line 8, in perform_calculation
    calc(x, y)
  File "stack_traces.py", line 12, in add
    return x + y
TypeError: unsupported operand type(s) for +: 'int' and 'str'


Same problem, but types are inverted. Remove manually quotes from '3' in line 46, or convert it to int
>>> type(int('3')) is type(7)
True


Traceback Problem 3
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 47, in <lambda>
    run_trace(3, lambda: perform_calculation(mult, '3', '3'))
  File "stack_traces.py", line 8, in perform_calculation
    calc(x, y)
  File "stack_traces.py", line 15, in mult
    return x * y
TypeError: can't multiply sequence by non-int of type 'str'


An error says: you can't multiply sequence by non-int of type in this example its string.
There are six sequence types: strings, Unicode strings, lists, tuples, buffers, and range objects. Which
cannot be mulitplied by anything besides int. Generally interpreter doesn't specify what should be expected behavior
when such thing occur so it just throw an error. Remove quotes in line 47 from '3', '3' or convert to int()


Traceback Problem 4
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 48, in <lambda>
    run_trace(4, lambda: perform_calculation(mult, [4], [3]))
  File "stack_traces.py", line 8, in perform_calculation
    calc(x, y)
  File "stack_traces.py", line 15, in mult
    return x * y
TypeError: can't multiply sequence by non-int of type 'list'


Same as above. Manually remove brackets in line 48 from [4] and [3] or extract those elements, there is only one in both so
it all boils down to this:
>>> x = [4][0]
>>> y = [3][0]
>>> x*y
12

If you really want to do [4]*[3] You can also write your own class to perform those kind of things. 
Just overload the operators with: def __mul__(self, arg):

to make it return something like this:
[a*b for a,b in zip([4],[3])]



Traceback Problem 5
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 49, in <lambda>
    run_trace(5, lambda: perform_calculation(innoc, '1', 3))
  File "stack_traces.py", line 8, in perform_calculation
    calc(x, y)
  File "stack_traces.py", line 22, in innoc
    spelunk()
  File "stack_traces.py", line 21, in spelunk
    raise ValueError('Invalid')
ValueError: Invalid


Traceback Problem 6
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 50, in <lambda>
    run_trace(6, lambda: comp_calc([1, 2, 3], 1, add))
    
  File "stack_traces.py", line 30, in comp_calc
    return [perform_calculation(calc, x_i, y_i) for x_i, y_i in zip(x, y)]
TypeError: zip argument #2 must support iteration


In line 30 you are trying to use zip() on (line 50) [1, 2, 3] and 1. The zip() function takes iterables 
(can be zero or more), aggregates them in a tuple, and return it. However 1 out of 2 passed arguments is not an iterator
Lists, tuples, dictionaries, sets, strings are iterable. All these objects have a iter() method which is used to 
get an iterator. To make this work make a second list - [1, 2, 3] and [1] in line 50.


Traceback Problem 7
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 51, in <lambda>
    run_trace(7, lambda: comp_calc([1, 2, [3]], [4, 5, 6], add))
  File "stack_traces.py", line 30, in comp_calc
  
    return [perform_calculation(calc, x_i, y_i) for x_i, y_i in zip(x, y)]
  File "stack_traces.py", line 30, in <listcomp>
  
    return [perform_calculation(calc, x_i, y_i) for x_i, y_i in zip(x, y)]
  File "stack_traces.py", line 8, in perform_calculation
    
    calc(x, y)
  File "stack_traces.py", line 12, in add
    return x + y
TypeError: can only concatenate list (not "int") to list


Traceback Problem 8
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 52, in <lambda>
    run_trace(8, lambda: calc_dict({'one': 1, 'two': '2'}, 'one', 'two', add))
  File "stack_traces.py", line 26, in calc_dict
    return perform_calculation(calc, d[k1], d[k2])
  File "stack_traces.py", line 8, in perform_calculation
    calc(x, y)
  File "stack_traces.py", line 12, in add
    return x + y
TypeError: unsupported operand type(s) for +: 'int' and 'str'


In line 52 you are providing a dictionary:
>>> d = {'one': 1, 'two': '2'}

In line 26 You are extracting it's values by key, 
d[k1] it's d['one'] because k1 is an element in a tuple 'one'
d[k2] it's d['two'] because k2 is an element in a tuple 'two'

>>> d['one'] 
1
>>> d['two']
'2'

And in line 12 trying do add type int to type string which is not allowed. Remove quotes from value '2'


Traceback Problem 9
===================
Traceback (most recent call last):
  File "stack_traces.py", line 36, in run_trace
    f()
  File "stack_traces.py", line 53, in <lambda>
    run_trace(9, lambda: calc_dict({}, 'one', 'two', add))
  File "stack_traces.py", line 26, in calc_dict
    return perform_calculation(calc, d[k1], d[k2])
KeyError: 'one'


In line 53 you provide an empty dictionary: {}
In line 26 you are trying to extract values by keys, which however cannot be done, because
such key doesn't exist (yet). Provide it in line 53:

{'one': 1, 'two': 5}




